

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pysmFISH.stitching_package.MicroscopeData &mdash; pysmFISH 0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> pysmFISH
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Welcome to pysmFISH!</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../cluster/index.html">Cluster setup</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../API/index.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pipeline/index.html">Processing pipeline</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license/index.html">License</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../citing/index.html">Author and citations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ind_tables/index.html">Indices and Tables</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pysmFISH</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pysmFISH.stitching_package.MicroscopeData</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pysmFISH.stitching_package.MicroscopeData</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="c1">#Own imports</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">inout</span>

<div class="viewcode-block" id="MicroscopeData"><a class="viewcode-back" href="../../../API/stitching/MicroscopeData_ref.html#pysmFISH.stitching_package.MicroscopeData.MicroscopeData">[docs]</a><span class="k">class</span> <span class="nc">MicroscopeData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Retrieves and stores the tile set and corner coordinates of each</span>
<span class="sd">    tile from raw coordinate input.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    y_flip: bool</span>
<span class="sd">        It is assumed that the microscope</span>
<span class="sd">        coordinates have their origin in right top of the image.</span>
<span class="sd">        During the stitching we use the left, top as the origin.</span>
<span class="sd">        Therefore the x-coordinates will be inverted by the</span>
<span class="sd">        normalization. But not the y-coords.</span>
<span class="sd">        The y_flip variable is designed for the cases where the</span>
<span class="sd">        microscope sequence is inverted in the y-direction. When</span>
<span class="sd">        set to True the y-coordinates will also be inverted</span>
<span class="sd">        before determining the tile set.</span>
<span class="sd">    x_coords: np.array</span>
<span class="sd">        Array of x coordinates, will be loaded</span>
<span class="sd">        as raw microscope coordinates in um by init() and</span>
<span class="sd">        converted to pixels and normalized to start at zero by</span>
<span class="sd">        normalize_coords().</span>
<span class="sd">    y_coords: np.array</span>
<span class="sd">        Array of y coordinates, will be loaded</span>
<span class="sd">        as raw microscope coordinates in um by init() and</span>
<span class="sd">        converted to pixels and normalized to start at zero by</span>
<span class="sd">        normalize_coords().</span>
<span class="sd">    z_coords: np.array</span>
<span class="sd">        Array of z coordinates, will be loaded</span>
<span class="sd">        as raw microscope coordinates in um by init() and</span>
<span class="sd">        converted to pixels and normalized to start at zero by</span>
<span class="sd">        normalize_coords().</span>
<span class="sd">    tile_nr: np.array</span>
<span class="sd">        The numbers of the tiles as found in coord_data.</span>
<span class="sd">    tile_set: np.array</span>
<span class="sd">        Array with the same shape as the</span>
<span class="sd">        tile set, values indicate the index at which the</span>
<span class="sd">        corresponing tile is found in tiles and tile_nr.</span>
<span class="sd">    running_av: float</span>
<span class="sd">        The estimated overlap between two</span>
<span class="sd">        neighbouring tiles in pixels, adapted for the tiles we</span>
<span class="sd">        already know the placement and overlap of.</span>
<span class="sd">    logger: logger</span>
<span class="sd">        logger instance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord_data</span><span class="p">,</span> <span class="n">y_flip</span><span class="p">,</span> <span class="n">nr_dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create looger, read-in the coordinates and tile numbers,</span>
<span class="sd">        create empty tile set.</span>

<span class="sd">        The tile numbers refer to the number in the file name of the</span>
<span class="sd">        image, they identify which image file belongs to which tile.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        coord_data: dict</span>
<span class="sd">            Dictionary with for each tile a list with</span>
<span class="sd">            x, y and z coordinate, where the key is the tile</span>
<span class="sd">            number.</span>
<span class="sd">            utils.experimental_metadata_parser() outputs such a</span>
<span class="sd">            dictionary when reading a file with microscope</span>
<span class="sd">            coordinates.</span>
<span class="sd">        y_flip: bool</span>
<span class="sd">            Designed for the cases where the</span>
<span class="sd">            microscope sequence is inverted in the</span>
<span class="sd">            y-direction. When set to True the y-coordinates will</span>
<span class="sd">            be inverted before determining the tile set. The</span>
<span class="sd">            x-direction is assumed to be always inverted.</span>
<span class="sd">        nr_dim: int</span>
<span class="sd">            Valid values: 2 and 3. The number of</span>
<span class="sd">            dimension the loaded tiles and stitched image will have.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Create logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1">#Set flag for y flip:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_flip</span> <span class="o">=</span> <span class="n">y_flip</span>

        <span class="c1">#Extract coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span>   <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span>   <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_coords</span>   <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_nr</span>    <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Do not substract 1 anymore to compensate for difference in</span>
        <span class="c1"># filenames and image numbers in coordinates file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Reading coord_data:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">coord_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;key: </span><span class="si">{}</span><span class="s1"> row: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_nr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="c1">#Make sure everything is np arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_coords</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_nr</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_nr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s2">&quot;Parsed microscope data:</span><span class="se">\n</span><span class="s2"> tile_nr: </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> &quot;</span>
                          <span class="o">+</span> <span class="s2">&quot;x: </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> y: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_nr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="p">))</span>
        <span class="c1">#self.logger.debug(&quot;x, y coord and tile nr: {} {} {}&quot;</span>
        <span class="c1">#                        .format(self.x_coords, self.y_coords, self.tile_nr))</span>
        <span class="c1">#Init tile set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Causes objects to be pickled without the logger attribute&quot;&quot;&quot;</span>
        <span class="n">class_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">class_dict</span><span class="p">[</span><span class="s1">&#39;logger&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">class_dict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores the logger atribute when unpickling the object&quot;&quot;&quot;</span>
        <span class="c1"># Restore instance attributes (i.e., filename and lineno).</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># Recreate the logger file, that has not been pickled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="MicroscopeData.normalize_coords"><a class="viewcode-back" href="../../../API/stitching/MicroscopeData_ref.html#pysmFISH.stitching_package.MicroscopeData.MicroscopeData.normalize_coords">[docs]</a>    <span class="k">def</span> <span class="nf">normalize_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalize the coordinates and put the origin in upper left</span>
<span class="sd">        corner.</span>
<span class="sd">        Takes list with absolute index, x, y values from microscope</span>
<span class="sd">        and normalizes, converts and inverts them to get the coordinates</span>
<span class="sd">        in pixels with the origin in left upper corner.</span>

<span class="sd">        NB:In the new microscope setup the origin is in the bottom right </span>
<span class="sd">        corner.</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        pixel_size: float</span>
<span class="sd">            The size of one pixel in the microscope</span>
<span class="sd">            image, used to convert the microscope coordinates to pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Normalizing coordinates&quot;</span><span class="p">)</span>
        <span class="c1"># Convert to pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span> <span class="o">/=</span> <span class="n">pixel_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span> <span class="o">/=</span> <span class="n">pixel_size</span>
        <span class="c1"># Commented out because in the new system the origin is in the bottom right</span>
        <span class="c1"># Flip the coordinate system to get tiles in right order (0,0 is left top)</span>

        <span class="c1"># OLD SYSTEM</span>

        <span class="c1"># self.x_coords *= -1</span>
        <span class="c1"># if self.y_flip:</span>
        <span class="c1">#     self.y_coords *= -1</span>
        <span class="c1"># # Normalization to get postive coordinates</span>
        <span class="c1"># x_min = np.amin(self.x_coords)</span>
        <span class="c1"># self.x_coords -= x_min</span>
        <span class="c1"># y_min = np.amin(self.y_coords)</span>
        <span class="c1"># self.y_coords -= y_min</span>

        <span class="c1"># self.x_coords *=1</span>
        <span class="c1"># self.y_coords *=1</span>
        <span class="c1"># if self.y_flip:</span>
        <span class="c1">#     self.y_coords *= -1</span>
        
        <span class="c1"># # NEW SYSTEM</span>

        <span class="c1"># Normalization to get postive coordinates</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span> <span class="o">-=</span> <span class="n">x_min</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span> <span class="o">-=</span> <span class="n">y_min</span>

        <span class="n">x_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span> <span class="o">-=</span> <span class="n">x_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">)</span>

        <span class="n">y_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span> <span class="o">-=</span> <span class="n">y_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="p">)</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s1">&#39;Normalized microscope data:</span><span class="se">\n</span><span class="s1"> tile_nr: </span><span class="si">{}</span><span class="s1"> &#39;</span>
                          <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> x: </span><span class="si">{}</span><span class="s1"> </span><span class="se">\n</span><span class="s1"> y: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_nr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="p">))</span></div>


<div class="viewcode-block" id="MicroscopeData.make_tile_set"><a class="viewcode-back" href="../../../API/stitching/MicroscopeData_ref.html#pysmFISH.stitching_package.MicroscopeData.MicroscopeData.make_tile_set">[docs]</a>    <span class="k">def</span> <span class="nf">make_tile_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">est_x_tol</span><span class="p">,</span> <span class="n">nr_pixels</span><span class="p">,</span> <span class="n">row_tol</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Based on the coordinates find a tile set.</span>

<span class="sd">        Use the coordinates to produce a tile set that has the shape</span>
<span class="sd">        of the grid the tiles should be placed on and for each tile in</span>
<span class="sd">        this grid gives the index for the tile_nr, x_coords and</span>
<span class="sd">        y_coords.</span>
<span class="sd">        Plots the coordinates when plot_avaible == True in inout.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        est_x_tol: int</span>
<span class="sd">            The estimated difference in the x</span>
<span class="sd">            direction between the corners of two</span>
<span class="sd">            neighbouring tiles in pixels</span>
<span class="sd">        nr_pixels: int</span>
<span class="sd">            Needed to estimate the distance between two separate tiles</span>
<span class="sd">        row_tol: int</span>
<span class="sd">            Row tolerance in pixels: The distance</span>
<span class="sd">            between y coordinates above which a tile is</span>
<span class="sd">            considered to belong to a new row. Default is None,</span>
<span class="sd">            which leads to 0.5 * nr_pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Making tile set&quot;</span><span class="p">)</span>
        <span class="c1"># If row_tolerance in not passed; set the row tolerance</span>
        <span class="c1"># according to number of pixels:</span>
        <span class="k">if</span> <span class="n">row_tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">row_tol</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">nr_pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Row tolereance: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row_tol</span><span class="p">))</span>
        <span class="c1"># Pre-sort y-coords</span>
        <span class="n">coord_inds</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_nr</span><span class="p">))</span>
        <span class="n">sorting_inds</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="p">)</span>
        <span class="n">sorted_coord_inds</span>   <span class="o">=</span> <span class="n">coord_inds</span><span class="p">[</span><span class="n">sorting_inds</span><span class="p">]</span>
        <span class="n">sorted_y</span>            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_coords</span><span class="p">[</span><span class="n">sorting_inds</span><span class="p">]</span>

        <span class="n">cur_row</span> <span class="o">=</span> <span class="p">[</span><span class="n">sorted_coord_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># Sort into rows, according to y-coordinates:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finding rows...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_y</span><span class="p">)):</span>
            <span class="c1"># Check the difference with the neighbour</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sorted_y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sorted_y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">row_tol</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cur_row</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Added row: </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cur_row</span><span class="p">))</span>
                <span class="n">cur_row</span> <span class="o">=</span> <span class="p">[</span><span class="n">sorted_coord_inds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_coord_inds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># Dump leftover in last row of tile_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cur_row</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Added last row: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cur_row</span><span class="p">))</span>

        <span class="c1"># Sort each row according to x-coordinates</span>
        <span class="c1"># Initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting within rows...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_av</span>  <span class="o">=</span> <span class="n">est_x_tol</span>
        <span class="n">x_max</span>       <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">)</span> <span class="o">+</span> <span class="n">nr_pixels</span>
        <span class="n">nr_col</span>      <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">x_max</span> <span class="o">/</span> <span class="n">est_x_tol</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s2">&quot;Estimated x-size of final picture: </span><span class="si">{}</span><span class="s2">, &quot;</span>
                          <span class="o">+</span> <span class="s2">&quot;Number of expected collumns in tile &quot;</span>
                          <span class="o">+</span> <span class="s2">&quot;set: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">nr_col</span><span class="p">))</span>
        <span class="n">av_counter</span>  <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Sort each row in tile_set</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">)):</span>
            <span class="c1"># Convert to np-array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># Sort row</span>
            <span class="n">sorting_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s2">&quot;Row </span><span class="si">{}</span><span class="s2">. &quot;</span>
                              <span class="o">+</span> <span class="s2">&quot;Sorted x-coordinates:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">[</span>
                                <span class="n">i</span><span class="p">]][</span><span class="n">sorting_inds</span><span class="p">]))</span>

            <span class="c1"># Local variable for easy adjustmet of sorted tiles</span>
            <span class="n">sorted_tiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sorting_inds</span><span class="p">]</span>
            <span class="c1">#self.logger.debug(&quot;Current sorted tiles {}&quot;.format(</span>
            <span class="c1"># sorted_tiles))</span>

            <span class="c1"># Make local copy with 0 appended, for easy adjustment of sorted x coordinates</span>
            <span class="n">sorted_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mf">0.0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">sorting_inds</span><span class="p">]))</span>

            <span class="c1"># Check for missing tiles:</span>
            <span class="c1"># Get distance between the tiles</span>
            <span class="n">diff_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sorted_x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">sorted_x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Row </span><span class="si">{}</span><span class="s2">. Distance between tiles:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">diff_x</span><span class="p">))</span>
            <span class="c1"># Update the average distance between directly adjacent tiles</span>
            <span class="n">neighbouring_tiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">diff_x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="n">nr_pixels</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">neighbouring_tiles</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1">#self.logger.debug(&quot;running av calculated with {}&quot;.format(diff_x[1:][neighbouring_tiles]))</span>
                <span class="c1">#self.logger.debug(&quot;running av calculated with {}&quot;.format(np.mean(diff_x[1:][neighbouring_tiles])))</span>
                <span class="n">av_counter</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">running_av</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">running_av</span>
                                    <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff_x</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">neighbouring_tiles</span><span class="p">]))</span> \
                                    <span class="o">/</span> <span class="n">av_counter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s2">&quot;Row </span><span class="si">{}</span><span class="s2">. Running average of estimated &quot;</span>
                              <span class="o">+</span> <span class="s2">&quot;overlap: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_av</span><span class="p">))</span>

            <span class="c1"># Find missing tiles (ignore the first tile, this one is checked later)</span>
            <span class="n">missing_tiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">diff_x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">nr_pixels</span><span class="p">)</span>
            <span class="n">missing_tiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">tile</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">missing_tiles</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Row </span><span class="si">{}</span><span class="s2">. Missing tiles: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span>
                <span class="n">missing_tiles</span><span class="p">))</span>

            <span class="c1"># Check how many tiles are missing and insert substituting value: -1</span>
            <span class="k">for</span> <span class="n">diff_ind</span> <span class="ow">in</span> <span class="n">missing_tiles</span><span class="p">:</span>
                <span class="c1">#self.logger.debug(&quot;Difference {}&quot;.format(diff_x[diff_ind]))</span>
                <span class="n">nr_missing_tiles</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">diff_x</span><span class="p">[</span><span class="n">diff_ind</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_av</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ins_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nr_missing_tiles</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
                <span class="c1">#self.logger.debug(&quot;inserting missing tile at index {}&quot;.format(diff_ind))</span>
                <span class="n">sorted_tiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sorted_tiles</span><span class="p">,</span> <span class="n">diff_ind</span><span class="p">,</span> <span class="n">ins_value</span><span class="p">)</span>
                <span class="c1">#self.logger.debug(&quot;inserting missing tile, tiles: {}&quot;.format(sorted_tiles))</span>

            <span class="c1"># Check for missing tiles at the start insert substituting value: -1</span>
            <span class="k">if</span> <span class="n">diff_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">row_tol</span><span class="p">:</span>
                <span class="n">nr_missing_tiles</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">diff_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_av</span><span class="p">))</span>
                <span class="n">ins_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nr_missing_tiles</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
                <span class="n">sorted_tiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sorted_tiles</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ins_value</span><span class="p">)</span>

            <span class="c1"># Check if this row is as long as the rest, if it not, assume</span>
            <span class="c1"># that tiles are missing at the end</span>
            <span class="c1"># and insert substituting value: -1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_tiles</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nr_col</span><span class="p">:</span>
                <span class="n">nr_missing_tiles</span> <span class="o">=</span> <span class="n">nr_col</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_tiles</span><span class="p">)</span>
                <span class="n">ins_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nr_missing_tiles</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
                <span class="n">sorted_tiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_tiles</span><span class="p">,</span> <span class="n">ins_value</span><span class="p">)</span>

            <span class="c1"># Mask the substituting value</span>
            <span class="n">sorted_tiles</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">(</span><span class="n">sorted_tiles</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Row </span><span class="si">{}</span><span class="s2">. Current sorted tiles </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">sorted_tiles</span><span class="p">))</span>
            <span class="c1"># Add to tile set:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="n">sorted_tiles</span>


        <span class="c1"># Mask the tile set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">)</span>
        <span class="c1">#self.tile_set = np.array(self.tile_set)</span>

        <span class="c1"># Logging and plot to check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tile set:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tile set shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tile numbers:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_nr</span><span class="p">))</span>

        <span class="n">inout</span><span class="o">.</span><span class="n">plot_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invert_yaxis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="MicroscopeData.check_tile_set"><a class="viewcode-back" href="../../../API/stitching/MicroscopeData_ref.html#pysmFISH.stitching_package.MicroscopeData.MicroscopeData.check_tile_set">[docs]</a>    <span class="k">def</span> <span class="nf">check_tile_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">est_x_tol</span><span class="p">,</span> <span class="n">nr_pixels</span><span class="p">,</span> <span class="n">row_tol</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the estimated overlap between tiles is close enough</span>
<span class="sd">        to the running average.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        est_x_tol: int</span>
<span class="sd">            The distance between two tiles in the</span>
<span class="sd">            x-direction as estimated before reading all coordinates.</span>
<span class="sd">        nr_pixels: int</span>
<span class="sd">            The the width of the tile in pixels.</span>
<span class="sd">        row_tol: int</span>
<span class="sd">            The distance between y coordinates</span>
<span class="sd">            above which a tile is considered to belong to a</span>
<span class="sd">            new row, this value is passed directly to</span>
<span class="sd">            make_tile_set. (default = None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_max</span>       <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_coords</span><span class="p">)</span>
        <span class="n">nr_col</span>      <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">x_max</span> <span class="o">/</span> <span class="n">est_x_tol</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">est_x_tol</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_av</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_set</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nr_col</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_tile_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">running_av</span><span class="p">,</span> <span class="n">nr_pixels</span><span class="p">,</span>
                                    <span class="n">row_tol</span> <span class="o">=</span> <span class="n">row_tol</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, simone codeluppi.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>